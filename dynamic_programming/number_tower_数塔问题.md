# 数塔问题
https://www.luogu.com.cn/problem/U218133

## 题目描述

有如下所示的数塔，要求从底层走到顶层，若每一步只能走到相邻的结点，则经过的结点的数字之和最大是多少？

![](https://cdn.luogu.com.cn/upload/image_hosting/73vupbld.png)

## 输入格式

输入数据首先包括一个整数 N (1 <= N <= 100)，表示数塔的高度，接下来用N行数字表示数塔，其中第i行有个i个整数，且所有的整数均在区间[0,99]内。

## 输出格式

从底层走到顶层经过的数字的最大和是多少？

## 样例 #1

### 样例输入 #1

```
5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5
```

### 样例输出 #1

```
30
```

## 提示
递推


## 解题思路
### 动态规划的递推写法
如果开一个二维数组f，其中f[i][j]存放第i层的第j个数字，那么就有
f[1][1]=5,
f[2][1]=8,
f[2][2]=3,
f[3][1]=12,
……,
f[5][4]=9,
f[5][5]=4。

如果尝试穷举所有路径，然后记录路径上的数字和的最大值，那么由于每层中的每个数字都会有两条分支路径，因此时间复杂度为O(2n)，这在n很大的情况下是不可以接受的。那么，产生这么大复杂度的原因是什么？

从5出发，按5->8->7的路线来到7，并枚举从7出发的到达最底层的所有路径。但是，之后当按5->3->7的路线再次来到7时，又会去枚举从7出发的到达最底层的所有路径，这就导致了从7出发的到达最底层的所有路径都被反复地访问。其实，可以把路径上能产生的最大和记录下来，这样就可以避免重复计算。

所以令dp[i][j]表示从第i行第j个数字出发的到达最底层的所有路径中能得到的最大和，例如dp[3][2]就是7的最大和。那么dp[1][1]就是最终答案，现在想办法求出它。

注意一个细节：如果要求出“从位置（1,1）到达最底层的最大和”dp[1][1]，那么一定要先求出它的两个子问题“从位置（2,1）到达最底层的最大和dp[2][1]”和“从位置（2,2）到达最底层的最大和dp[2][2]”，即进行了一次决策：走数字5的左下还是右下。于是dp[1][1]就是dp[2][1]和dp[2][2]的较大值加上5。公式：

$dp[1][1] = max(dp[2][1], dp[2][2]) + f[1][1]$

归纳：如果要求出dp[i][j]，那么一定要求出它的两个子问题“从位置(i+1,j)到达最底层的最大和dp[i+1][j]”和“从位置(i+1,j+1)到达最底层的最大和dp[i+1][j+1]”，即进行了一次决策：走位置(i,j)的左下还是右下。公式：

$dp[i][j] = max(dp[i+1][j], dp[i+1][j+1]) + f[i][j]$

把dp[i][j]称为问题的状态，公式称为状态转移方程，它把状态dp[i][j]转移为dp[i+1][j]和dp[i+1][j+1]。可以发现，状态dp[i][j]只与第i+1层的状态有关，而与其他层的状态无关。那么如果总是将层号增大，什么时候会到头呢？其实，数塔的最后一层的dp值总是等于元素本身，即dp[n][j]==f[n][j](1<=j<=n)，把这种可以直接确定其结果的部分称为边界，而动态规划的递推写法总是从这些边界出发，通过状态转移方程扩散到整个dp数组。

这样就可以从最底层各位置的dp值开始，不断往上求出每一层各位置的dp值，最后就会得到dp[1][1]，即为想要的答案。
